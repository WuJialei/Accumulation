# 关于ZooKeeper的学习总结

**1 分布式相关理论**

--1.1 事务(本地事务处理或者集中式事务处理)

- 事务概念：对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性

- 事务四大特性(ACID)
   - 原子性（Atomicity）:原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响
   - 一致性（Consistency）:事务是从一个一致性状态转移到另一个一致性的状态。事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到
   - 隔离性（Isolation）:隔离性是当多个用户并发访问数据库时，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账
   - 持久性（Durability）:持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作

- 事务的隔离级别
   - 读未提交：另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读
   - 读提交：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致
   - 可重复读：在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象
   - 串行化：最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样

- 事务的并发问题
   - 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
   - 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致
   - 幻读：可重复读隔离级别解决了不可重复读问题，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读
   - 幻读与不可重复读区别：不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表

- 事务隔离级别与事务并发问题关系
    |事务隔离级别|脏读|不可重复读|幻读|
    |--|--|--|--|
    |读为提交|是|是|是|
    |读提交|否|是|是|
    |可重复读|否|否|是|
    |串行化|否|否|否|

- MySQL默认的事务隔离级别为repeatable-read可重复读，事务的隔离级别要得到底层数据库引擎的支持。未提交读时，写数据只会锁住相应的行；可重复读时，写数据会锁住整张表；串行化时，读写数据都会锁住整张表。隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。

--1.2 分布式事务

- 事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点之上

- 分布式事务是指会涉及到操作多个数据库的事务。其实就是将对同一库事务的概念扩大到了对多个库的事务。目的是为了保证分布式系统中的数据一致性。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）

- 分布式系统经典理论
   - CAP
   - BASE

- CAP
   - CAP理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项
   - Consistency 一致性，一致性指“all nodes see the same data at the same time”，说的就是数据一致性。即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。以下有三种一致性策略
      - 强一致性：要求更新过的数据能被后续的访问都能看到
      - 弱一致性：能容忍后续的部分或者全部访问不到
      - 最终一致性：经过一段时间后要求能访问到更新后的数据
      - CAP中说，不可能同时满足的这个一致性指的是强一致性
   - Availability 可用性，可用性指“Reads and writes always succeed”，即在正常响应时间服务一直可用
   - Partition Tolerance分区容错性，分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务
   - 在CAP理论中。C，A，P三者并不是平等的，对于一个分布式系统来说。P是一个基本要求，CAP三者中，只能在CA两者之间做权衡，并且要想尽办法提升P
   - CP without A，如果一个分布式系统不要求强的可用性，即容许系统停机或者长时间无响应的话，就可以在CAP三者中保障CP而舍弃A。一个保证了CP而一个舍弃了A的分布式系统，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实也不少，其中最典型的就是很多分布式数据库，在发生极端情况时，优先保证数据的强一致性，代价就是舍弃系统的可用性。如Redis、HBase等，还有分布式系统中常用的Zookeeper也是在CAP三者之中选择优先保证CP的
   - AP wihtout C，要高可用并允许分区，则需放弃一致性。一旦网络问题发生，节点之间可能会失去联系。为了保证高可用，需要在用户访问时可以马上得到返回，则每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。这种舍弃强一致性而保证系统的分区容错性和可用性的场景和案例非常多。前面我们介绍可用性的时候说到过，很多系统在可用性方面会做很多事情来保证系统的全年可用性可以达到N个9，所以，对于很多业务系统来说，比如淘宝的购物，12306的买票。都是在可用性和一致性之间舍弃了一致性而选择可用性
   
- BASE
   - BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）
   - 基本可用（Basically Available）：基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用
   - 软状态（ Soft State）：软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性
   - 最终一致性（ Eventual Consistency）：最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态
   - ACID和BASE的区别与联系：ACID是传统数据库常用的设计理念，追求强一致性模型。BASE支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。ACID和BASE代表了两种截然相反的设计哲学。在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此ACID和BASE又会结合使用

--1.3 分布式一致性的协议和算法

- 协议和算法
   - 2PC：二阶提交协议（Two Phase Commitment Protocol）
   - 3PC：三阶提交协议（Three Phase Commitment Protocol）
   - Paxos：帕克索斯算法

- 2PC
   - 两个阶段是指：第一阶段：准备阶段(投票阶段)和第二阶段：提交阶段（执行阶段）。
   - 准备阶段：事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态
   - 提交阶段：如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源
   - 缺点：协调者单点故障问题，协调者发生故障。参与者会一直阻塞下去；在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作；协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象

- 3PC
   - 3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段
   - CanCommit阶段：3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应
   - PreCommit阶段：协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。根据响应情况，有以下两种可能。假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行；假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断
   - doCommit阶段：该阶段进行真正的事务提交，在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）
   - 2PC与3PC的区别：相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况

- Paxos
   - Lamport虚拟了一个叫做Paxos的希腊城邦，这个岛按照议会民主制的政治模式制订法律，将议员的角色分为 proposers，acceptors，和 learners（允许身兼数职）
      - proposers 提出提案，提案信息包括提案编号和提议的 value
      - acceptor 收到提案后可以接受（accept）提案，若提案获得多数派（majority）的 acceptors 的接受，则称该提案被批准（chosen）
      - learners 只能“学习”被批准的提案
   - 决议的提出与批准：一个决议分为两个阶段
      - prepare阶段
         - proposer选择一个提案编号n并将prepare请求发送给acceptors中的一个多数派
         - acceptor收到prepare消息后，如果提案的编号大于它已经回复的所有prepare消息(回复消息表示接受accept)，则acceptor将自己上次接受的提案回复给proposer，并承诺不再回复小于n的提案
      - 批准阶段
         - 当一个proposer收到了多数acceptors对prepare的回复后，就进入批准阶段。它要向回复prepare请求的acceptors发送accept请求，包括编号n和根据P2c决定的value
         - 在不违背自己向其他proposer的承诺的前提下，acceptor收到accept请求后即批准这个请求
   - 决议的发布：当acceptors批准一个value时，将这个消息发送给所有learners。但是这个方法会导致消息量过大。因此acceptors需要将accept消息发送给learners的一个子集，然后由这些learners去通知所有learners。

--1.4 本部分参考

- [史上最全的数据库面试题，不看绝对后悔](https://www.nowcoder.com/discuss/135748)
- [学习分布式不得不会的ACP理论](https://mp.weixin.qq.com/s/DUOsYUTuKM6mhahqiaWXCA)
- [分布式系统的BASE理论](http://www.hollischuang.com/archives/672)
- [关于分布式事务、两阶段提交协议、三阶提交协议](http://www.hollischuang.com/archives/681)
- [Paxos算法](https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95)
- []()