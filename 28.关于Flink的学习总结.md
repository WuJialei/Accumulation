# 关于Flink的学习总结

**1 Flink的概念**

--1.1 基本概念

- 分布式

- 支持流处理和批处理

- 开源计算平台

--1.2 特点

- 统一的批处理和流处理系统

- Flink流处理的容错机制

- Flink流处理的时间窗口

**2 Flink的架构**

--2.1 基本架构

2.1.1 Flink包含了两种类型的处理器

- JobManager(Master)
   - 负责接收 flink 的作业，调度task，协调检查点，协调失败时恢复等
   - 收集 job 的状态、管理 TaskManagers
   - Flink运行时至少存在一个master处理器，如果配置高可用模式则会存在多个master处理器，它们其中有一个是leader，其他的都是standby

- TaskManager(Worker)
   - Flink中资源管理的基本组件，是所有执行任务的基本容器，提供了内存管理、IO管理、通信管理等一系列功能
   - MemoryManager Flink并没有把所有内存的管理都委托给JVM，因为JVM普遍存在着存储对象密度低、大内存时GC对系统影响大等问题。所以Flink自己抽象了一套内存管理机制，将所有对象序列化后放在自己的MemorySegment上进行管理
   - IOManager flink通过IOManager管理磁盘IO的过程，提供了同步和异步两种写模式，又进一步区分了block、buffer和bulk三种读写方式
   - NetworkEnvironment 是TaskManager的网络 IO 组件，包含了追踪中间结果和数据交换的数据结构。它的构造器会统一将配置的内存先分配出来，抽象成 NetworkBufferPool 统一管理内存的申请和释放
   - Flink运行时至少会存在一个worker处理器

2.1.2 Flink中计算资源的介绍

- TaskManager：Flink中资源管理的基本组件，是所有执行任务的基本容器
   - 每个TaskManager都是一个独立的JVM进程

- TaskManager可以分为一个或者多个Task Slot：每个Task Slot代表了TaskManager的一个固定大小的资源子集。例如，一个拥有3个slot的 TaskManager，会将其管理的内存平均分成三分分给各个slot。将资源slot化意味着来自不同job的task不会为了内存而竞争，而是每个task都拥有一定数量的内存储备。
   - 同一JVM(TaskManager)中的任务(Task Slot)共享TCP连接和心跳消息
   - TaskManager的一个Slot代表一个可用线程，该线程具有固定的内存，注意 Slot 只对内存隔离，没有对CPU隔离
   - 每个slot能运行一个或多个task(一个task是一个线程，task是执行计算的最小结构)
   - 每个TaskManager的Task Slot数目代表了该TaskManager的并发能力，任务的并发能力由所有TaskManager的Task Slot数目决定。有两个 Task Manager，每个 TaskManager有三个slot，这样我们的算子最大并行度那么就可以达到6个
   - slot 的数量通常与每个TaskManager的可用CPU内核数成比例。一般情况下你的slot数是每个TaskManager的cpu的核数
   - parallelism与slot的区别，参考[Flink--对parallelism 和 slot的理解](https://www.jianshu.com/p/b58988bcfb48)：slot是指taskmanager的并发执行能力；parallelism是指 taskmanager 实际使用的并发能力(并行度)；taskmanager.numberOfTaskSlots:3；即每一个 taskmanager 中的分配3个TaskSlot, 3个 taskmanager 一共有 9 个 TaskSlot。parallelism.default:1；即运行程序默认的并行度为 1，9 个 TaskSlot 只用了 1 个，有 8 个空闲。设置合适的并行度才能提高效率

- Task Slot允许多个task共享：每个Task Slot能运行一个或多个task，为了资源更充分的利用，Flink提出了SlotSharingGroup，尽可能地让多个task共享一个slot
   - 条件：它们都来自同一个Job的不同task的subtask(同一job的一个task下的相同subtask应该并行，不能放在同一个slot中)
   - slot共享有以下两点好处：1.Flink集群所需的task slots数与job中最高的并行度一致。也就是说我们不需要再去计算一个程序总共会起多少个task了；2.更容易获得更充分的资源利用。如果没有slot共享，那么非密集型操作source/flatmap就会占用同密集型操作 keyAggregation/sink 一样多的资源。如果有slot共享，将基线的2个并行度增加到6个，能充分利用slot资源，同时保证每个TaskManager能平均分配到重的subtasks(该部分看参考链接的图)

- 算子operators的Chaining：Flink提出了Chaining，尽可能地将operators chain在一起作为一个task来处理
   - Flink会尽可能地将operator的subtask链接（chain）在一起形成task。每个task在一个线程中执行。
   - 好处：将operators链接成task是非常有效的优化，它能减少线程之间的切换，减少消息的序列化/反序列化，减少数据在缓冲区的交换，减少了延迟的同时提高整体的吞吐量
   - 不是任意两个operator就能chain一起的，其条件还是很苛刻的(具体条件可看链接)


--2.2 运行架构

--备注：该部分主要参考以下内容

- [Cris 带你快速入门 Flink之二 Flink基本架构](https://juejin.im/post/5c4f16dbe51d454f342fb7e7#heading-4)
- [追源索骥：透过源码看懂Flink核心框架的执行流程之3. 任务的调度与执行](https://www.cnblogs.com/bethunebtj/p/9168274.html#3-%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%89%A7%E8%A1%8C)
- [Flink 原理与实现：理解 Flink 中的计算资源](http://wuchong.me/blog/2016/05/09/flink-internals-understanding-execution-resources/)